\section{Certificates and vote diffusion}

\niols[inline]{This section is really just a dump of my brain. Nothing here is a
  final decision, and probably there are many mistakes.}

\subsection{One vs two protocols}

Pro of one protocol:
\begin{itemize}
\item some optimisations such as someone asking for votes and getting a cert
  instead
\item only one protocol to understand and maintain
\item no need for synchronisation between the two protocols (eg. if we get a
  cert we don’t need to ask for votes anymore)
\end{itemize}

Pro of two protocols:
\begin{itemize}
\item each protocol conceptually simpler
\item can reuse a generalised version of Tx-Submission for vote diffusion
\item can maybe even reuse it for cert diffusion
\end{itemize}

Leaning towards two protocols when seeing this list.

\subsection{Vote diffusion mini-protocol}

\begin{itemize}
\item Instance of the generic object diffusion mini-protocol
  (\autoref{object-diffusion-protocol}) where id = id’ = voteId, and obj = vote.

\item The size of a vote is constant so we do not need to transmit the size.

\item Probably we only start it once we’re caught-up (or almost caught-up?).

\item Probably we don’t need an initial payload; worst case we waste a bit of
  network once we reach almost caught-up.

\item We want to avoid missing a quorum when almost caught-up and when we put
  something in our immutable DB.

\item We want to download all the votes because there could be votes
  equivocation.
\end{itemize}

\subsection{Certificate diffusion mini-protocol}

\begin{itemize}
\item We can assume that there is only one block that reaches quorum per round.
  In particular, if we have a cert for a round, we do not care at all about any
  other cert in the same round.

\item Probably useless when caught-up. We might want to keep it running just for
  the awkward situation where we really didn’t get all the votes but there is a
  cert. Most of the time, we should get all the votes, realise there is a
  quorum, and therefore know to ignore the certs that peer tell us about.

\item What about reusing the generic object diffusion mini-protocol?
  (\autoref{object-diffusion-protocol})
  \begin{itemize}
  \item id = id’ = roundNumber

  \item obj = cert

  \item an initial payload telling the peer from which round number we want to
    start.

  \item While syncing, we want to know for sure that a round has no
    certificates, because that influences the GDD. So we need a way to be sure
    that it isn’t going to come later. Probably we can just solve this by making
    it mandatory to have round numbers in increasing order for the historical
    chain. (For caught-up nodes, certs might arrive in another order)

  \item The information of round numbers can be made much more compact than a
    list of Word16, because we just need a bitset. We could ask for a range of
    round and get a bitset covering them. Maybe we can generalise in the obj
    diff protocol not only the notion of id but the notion of list of ids.
    Basically we make abstract the [(id, size)] and we just ask for a function
    that returns a [(id, size)] given the abstract thingie
  \end{itemize}
\end{itemize}
