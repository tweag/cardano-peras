\section{Vote and certificate diffusion}%
\label{sec:certificate-vote-diffusion}

This section presents our proposed protocols for diffusion of votes and certificates between peers.
\Cref{sec:cert-vote-diff-discussion} presents a discussion about alternative designs that we have considered, \cref{sec:vote-diffusion} presents our protocol for vote diffusion, and \cref{sec:certificate-diffusion} presents our protocol for certificate diffusion.

\subsection{Discussion on the chosen design}%
\label{sec:cert-vote-diff-discussion}

\niols{Should this disappear? Or maybe go in the appendix?}

The use of one combined protocol provides the following upsides:
%
\begin{itemize}
\item
  It allows for some optimisations, such as responding with a certificate when a client asks for a vote that it subsumes.

\item
  There only one protocol to understand and maintain.

\item
  It aleviates the need for synchronisation between the two protocols (e.g., if we get a certificate, then we do not need to request votes anymore) and avoids us having to reason on the interactions between the two protocols.
\end{itemize}

The use of distinct protocols for certificate diffusion and vote diffusion provides the following upsides:

\begin{itemize}
\item
  Each protocol, by virtue of being smaller, is also conceptually simpler.

\item
  We can hope to use similar protocols for certificate diffusion and vote diffusion.
  In fact, we can hope to reuse our generic object diffusion protocol (\cref{sec:object-diffusion-protocol}) for everything.
\end{itemize}

We propose to go for separate protocols.
We find the upside of conceptually simpler protocols convincing, and even more if we manage to reuse an existing one.
We believe that the lost optimisation is in fact not so significant, and that the synchronisation between the two protocols will not be difficult to implement.

Once that is decided, remains the question, for both certificate and vote diffusion, of whether we should introduce mini-protocols tailored to the specific use case of those objects, or if we should reuse existing protocols, for instance inspired by Tx-Submission.

\niols[inline]{TODO: Discussion}

\subsection{Vote diffusion mini-protocol}%
\label{sec:vote-diffusion}

We propose to use the generic object diffusion mini-protocol (\cref{sec:object-diffusion-protocol}) instantiated for votes.
In particular, we want:
%
\begin{description}
\item[\argfont{object}] a vote
\item[\argfont{id}] the pair of a round number and a committee seat
  identifier\niols{what is that? a hash? a number?}
\item[\argfont{objectIds}] a list of \argfont{id}s
\item[\argfont{responseToIds}] the identity function --- \(\argfont{objectIds} =
  [\argfont{id}]\) already
\item[\argfont{initialPayload}] unit --- no payload is necessary
\end{description}

A few notes:

\begin{itemize}
\item
  The size of a vote is constant so we do not need to transmit the size at any point, the client will be able to keep this in mind.

\item
  We do not need to download the votes on the historical chain, so we can just start the protocol with the state of the server at that point, and there is no need to transmit an initial payload to explain since when we want to download votes.

\item
  We want to avoid missing a quorum when almost caught-up and when we put something in our immutable DB.\niols{I can't remember what I meant by that, but probably there is an important question of when we should start downloading votes. Is there a risk, if we want until we are caught-up?}

\item
  We want to download all the votes because there could be votes equivocation.
  \alex{I don't immediately see a relation between these two things.}
  \niols{I also don't know. What if we remove this line and just say that we
    want to download the votes reasonably fast?}
\end{itemize}

\subsection{Certificate diffusion mini-protocol}%
\label{sec:certificate-diffusion}

\paragraph{Requirements.}

Diffusion of certificates is required in the following contexts:

\begin{enumerate}
\item
  Primarily, syncing nodes/pools need to be able to obtain historical certificates in order to choose the correct historical chain, even though certificates do not (meaningfully) affect the ledger state.

  Concretely, nodes bootstrapping via Ouroboros Genesis (to minimize trust assumptions) need to be able to assess the weight of competing historical chains in order to resist adversarial \emph{long-range attacks}.
  Computing the weight of a chain requires the corresponding certificates indicating which blocks are boosted (potentially multiple times).
  See \cref{sec:weighted genesis} for more details.
  Even if a syncing node did not encounter any adversarial challengers (and hence didn't ever need to compute weight), it still must get all certificates in order to in turn be able to serve them to \emph{other} peers syncing \emph{from} that node, as these \emph{do} might require them.
  Briefly, there is a \enquote{duty to remember} certificates even if they are not directly useful for the caught-up node anymore.

  The Cardano implementation of Ouroboros Genesis \parencite{genesis-implementation-documentation} requires that syncing nodes are always connected to at least one honest peer.
  In practice, this is guaranteed by connectiong to a sufficient number of appropriately sampled peers.
  To reduce the load on these peers (and for a more efficient use of resources generally), downloading the same certificates from multiple peers must be avoided.\footnote{This is an extension of the motivation e.g.\ for the \emph{ChainSync Jumping} optimization \parencite{genesis-implementation-documentation} as part of the Cardano Genesis implementation.}
\item
  Additionally, diffusing certificates even between caught-up nodes allows mitigating vote-equivocation attacks, cf.~\cref{sec:attack equivocations}.
\end{enumerate}

We note that certificates can also be diffused in blocks (in order to coordinate the end of a cooldown); this is orthogonal to the discussion in this section.

\paragraph{Using object diffusion.}

We propose to use the generic object diffusion mini-protocol (\cref{sec:object-diffusion-protocol}) instantiated for certificates.
In particular, we want:

\begin{description}
\item [\argfont{object}]
  A certificate.
\item [\argfont{id}]
  A Peras round number.
\item [\argfont{objectIds}, \argfont{responseToIds}]
  In its simplest form, a list of Peras round numbers.

  As an optimization, compact/compressed representations are possible, for example
  \begin{itemize}
  \item
    a round followed by a bitset for the subsequent rounds, indicating whether a certificate is present, or
  \item
    a round followed by a run-length encoding of the subsequent rounds.
    This is motivated by the observation that in Peras, rounds are (not) successful in larger runs, either because all rounds are successful due to sufficient honest votes, and if not, a lengthy cooldown period (with no successful rounds to due honest abstention) of unsuccessful rounds.
  \end{itemize}
  The \argfont{responseToIds} function is then decoding this compact representation.
\item [\argfont{initialPayload}]
  A Peras round number.

  Partially synced/recently caught-up peers can use this to receive certificates starting from the first round for which they do not yet have a certificate, avoiding the transfer of older, already-downloaded data.\footnote{
  This is conceptually analogous to \msg{MsgFindIntersect} in the ChainSync protocol.}
\end{description}

An honest server answers requests for more round numbers by monotonically sending those for which it has a certificate in ascending order, until the client is caught-up, in which case the server blocks (or returns empty results) until it observes new certificates arising from successful Peras voting rounds.
At any time, it will serve the certificates corresponding to unacknowledged round numbers, while enforcing an upper bound on the this quantity.

This design leverages the fact that there can only be at most one certificate per round, which allows us to elide data like the point of the block that is being certified/boosted.
In particular, it does not matter who we download a certificate for a particular from.

We now give a high-level description of the envisioned dynamics of this protocol.

\begin{itemize}
\item
  Consider a syncing node via Ouroboros Genesis which still needs to catch up a significant part of the historical chain.
  The node continually requests sizeable chunks of round numbers via \msg{MsgRequestObjIdsNonBlocking} for each peers.
  For every round number that is advertised by at least one peer, the corresponding certificates are downloaded from the peers via \msg{MsgRequestObjs} (as a first step, a singular designated peer which a simple batching strategy could be used; but more sophisticated strategies, similar to the existing BlockFetch logic are conceivable).
  The client uses protocol-level pipelining to avoid round-trip delays and to make full use of the available bandwidth.
\item
  As the node is eventually done catching up, its peers run out of certificates to serve, and the node will start sending \msg{MsgRequestObjIdsBlocking} instead.\footnote{
  In particular, an incomplete/empty reply to \msg{MsgRequestObjIdsBlocking} is analogous to \msg{MsgAwaitReply} in the ChainSync protocol.}
  Usually, it will receive one new round number per peer every \perasRoundSlots{} slots, but given that the node now participates in vote diffusion, it is not necessary to actually download the certificate.

  An exception is the scenario where the node has downloaded all votes for a round without observing a quorum, but still received this round number via the certificate diffusion protocol.
  In this case, the node will download the certificate via certificate diffusion.
  This can only happen due to adversarial vote equivocation, see \cref{sec:attack equivocations}.
\end{itemize}

Clients can ensure progress in this protocol w.r.t.\ adversarial servers by enforcing appropriate timeouts and a monotonicity property on the advertised round numbers:
\begin{enumerate}
\item
  Prompt delivery of requested certificates can be ensured by protocol-level timeouts, or a via more elaborate mechanism like a \emph{leaky token bucket} as used in the Cardnao Genesis implementation  \parencite{genesis-implementation-documentation} which handles temporary latency spikes more gracefully.
\item\label{enumi:cert diffusion monotonicity}
  The sequence of round numbers sent by the server must increase strictly monotonically, or alternatively (as part of an implementation tradeoff) \emph{almost} monotonically, as honest nodes can observe the certificate for round $r$ before the one for round $s$ despite $r>s$, but only for small $r-s$, see \cref{sec:votes certs from the past}.\footnote{
  More formally, we call a sequence ${(a_k)}_{k\in \mathbb{N}}$ \emph{$d$-monotonic} if $\max_{i<k} a_i < a_{i+1} + d$ for all $i\in \mathbb{N}$.
  Let $r_\bullet = {(r_k)}_{k\in\mathbb{N}}$ be the sequence of round numbers sent by the server.
  Letting the client enforce $0$-monotonicity of $r_\bullet$ simplifies the client at the cost of the server, whereas enforcing $d$-monotonicity for $d=1$ (or other small positive values) has the opposite tradeoff.
}
\end{enumerate}

Finally, we note that in order to conclude that a round \emph{does} have a corresponding certificate, it is enough to download such a cert from any peer, while concluding that there is \emph{no} certificate for a round $r$ requires information from \emph{all} peers (in the form of advertising a certificate for a round sufficiently larger than $r$ as per~\ref{enumi:cert diffusion monotonicity}, or by the peer indicating that they have no more certificates at the moment).

%%% Local Variables:
%%% mode: latex
%%% TeX-engine: xetex
%%% TeX-master: "../peras-design"
%%% End:
